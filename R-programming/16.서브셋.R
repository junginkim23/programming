#서브셋: 전체 데이터 셋의 일부분으로 구성되어 있는 부분집합 

#데이터 셋 -> 서브셋 만들기 
#1)R이 제공하는 인덱싱 방법 이용

str(mtcars)
#output
'data.frame':	32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: num  4 4 1 1 2 1 4 2 2 4 ...

mtcars$mpg
#output ->벡터의 형태로 나온다.
[1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8
[12] 16.4 17.3 15.2 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5
[23] 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4

mtcars[["mpg"]]
#output
[1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8
[12] 16.4 17.3 15.2 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5
[23] 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4

mtcars[[1]] -> 벡터의 형태로 나온다.
[1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8
[12] 16.4 17.3 15.2 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5
[23] 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4

mtcars[c(1,4)] #=mtcars[c("mpg","hp")]
#output -> 데이터 프레임의 형태로 나온다.
mpg  hp
Mazda RX4           21.0 110
Mazda RX4 Wag       21.0 110
Datsun 710          22.8  93
Hornet 4 Drive      21.4 110
Hornet Sportabout   18.7 175
Valiant             18.1 105
Duster 360          14.3 245
Merc 240D           24.4  62
Merc 230            22.8  95
Merc 280            19.2 123
Merc 280C           17.8 123
Merc 450SE          16.4 180
Merc 450SL          17.3 180
Merc 450SLC         15.2 180
Cadillac Fleetwood  10.4 205
Lincoln Continental 10.4 215
Chrysler Imperial   14.7 230
Fiat 128            32.4  66
Honda Civic         30.4  52
Toyota Corolla      33.9  65
Toyota Corona       21.5  97
Dodge Challenger    15.5 150
AMC Javelin         15.2 150
Camaro Z28          13.3 245
Pontiac Firebird    19.2 175
Fiat X1-9           27.3  66
Porsche 914-2       26.0  91
Lotus Europa        30.4 113
Ford Pantera L      15.8 264
Ferrari Dino        19.7 175
Maserati Bora       15.0 335
Volvo 142E          21.4 109

mtcars[-c(2,3,5,7:11)] #음수로 지정된 인덱스(열)를 제외한 나머지가 출력된다.

#음의 인덱스를 주게 되면 해당 데이터 셋에서 음의 인덱스를 제거해달라는 뜻이다.
mtcars[-1] #첫 번째 열을 제외한 나머지 열 제거 
mtcars[1] <- NULL #위의 코드와 같은 의미 

#음의 인덱스와 양의 인덱스를 섞어서 사용할 수 없다.
mtcars[c(-1,2)]
#output -> 에러 발생
Error in `[.default`(mtcars, c(-1, 2)) : 
  only 0's may be mixed with negative subscripts'
  
#데이터 프레임 -> 행과 열을 갖는 2차원의 데이터 구조이기 때문에 원하는 행과 열을 지정해서 서브셋 생성 가능
str(iris)
iris[1:5,]
#output
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa

iris[,c("Sepal.Length","Sepal.Width")] #"Sepal.Length","Sepal.Width"로 구성된 데이터 프레임이 출력된다.

#하나의 열만을 선택할 때는 주의할 필요가 있다. 자칫하다간 데이터 프레임의 형태가 아닌 벡터 형태로 출력될 수 있기 때문이다.
iris[,"Sepal.Length"]
#output
[1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3
[15] 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2
[29] 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5
[43] 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7
[57] 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6
[71] 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0
[85] 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2
[99] 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4
[113] 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2
[127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9
[141] 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9
#이렇게 출력되는 이유는 R은 복잡한 객체를 최대한 단순화 시키려고 한다.

iris[,"Sepal.Length",drop=FALSE] #drop=FALSE를 인수로 지정해주면 벡터의 형태가 아닌 데이터 프레임의 형태로 출력된다.
#데이터 프레임에서 하나의 열만을 추출하고 싶을 때는 행렬 인덱싱 보다는 리스트 인덱싱을 사용하는 것이 더 좋을 수 있다.
iris["Sepal.Length"] #iris[,"Sepal.Length",drop=FALSE]와 같은 결과를 출력한다.

iris[1:5,c("Sepal.Length","Sepal.Width")]
#output
  Sepal.Length Sepal.Width
1          5.1         3.5
2          4.9         3.0
3          4.7         3.2
4          4.6         3.1
5          5.0         3.6

#조건을 만족하는 서브셋 생성
iris[iris$Sepal.Length>7,] #Sepal.Lengthrk 7보다 큰 행만을 추출 모든 열에 관해서
iris[iris$Sepal.Length>7,c("Sepal.Length","Sepal.Width","Species")]

#subset함수 사용
subset(iris,
       subset=(Sepal.Length>7),
       select=c("Sepal.Length","Sepal.Width","Species"))
#첫 번째 인수에 데이터 셋, subset 인수에 행의 조건, select 인수에 추출하고 싶은 열을 지정한다.

#sample 함수: 무작위 표본을 추출할 수 있다. 
sample(x=1:10,size=5) #x는 표본 추출할 대상 데이터 셋을 벡터 형식으로 지정 받는다, size 인수에는 추출할 표본의 개수를 지정한다. 
sample(x=10,size=5) #x에 정수를 지정할 수도 있는데, 1:10과 동일하게 작용한다.

#복원 추출(추출한 것을 되돌리고 나서 다시 추출) & 비복원 추출(추출한 것을 되돌리지 않고 다시 추출)
#1)복원 추출
sample(x=10,size=5,replace=TRUE) #output:5 9 5 2 1 -> 5가 두 번 나왔다. 복원 추출 

#2)비복원 추출
sample(x=10,size=5,replace=FALSE) 

sample(10) #무작위로 추출된 10개의 순열이 나온다.

#무작위로 추출되는게 아니라, 동일한 결과를 얻고 싶을 때. 
#1)seed 값 지정. -> R이 항상 동일한 값을 출력한다.
set.seed(1)
sample(x=10,size=5,replace=TRUE) #seed 값을 실행하고 실행하면 동일한 결과가 계속 나오는 것을 확인할 수 있다.

#행이 무작위로 추출된 데이터 프레임을 얻고 싶지만, sample에 그냥 지정을 해버리면 열의 값이 무작위로 지정된 데이터프레임이 출력된다.
sample(iris,3) #iris 데이터 셋의 5개의 열에서 3개의 열을 무작위로 추출하여 데이터 프레임을 출력해준다.

#iris데이터 셋의 행을 대상으로 3개의 행을 무작위로 뽑는다. 그리고 봅은 그 행의 값을 다시 iris 데이터 셋의 행의 위치에 넣어주면 무작위로 선택된 3개의 행에 대한 데이터프레임이 출력된다.
set.seed(1)
index <- sample(nrow(iris),3) #iris데이터 셋의 행을 대상으로 3개의 행을 무작위로 추출한다.  
index
iris[index,]

#데이터 셋에 중복된 값을 찾아 제거 -> 이 때 사용하는 함수 duplicated 함수
duplicated(c(1,2,3,1,1,4,3))
#output:[1] FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE -> 원소가 처음 출력되면 false, 처음이 아니면(중복이 발생하면) true 반환

#데이터 프레임을 생성해서 중복된 행을 찾고, 중복된 행을 제외한 나머지 행을 출력해라.
id <- c("A001","A002","A006")
name <- c("Mouse","Keyboard","USB")
price <- c(30000,90000,50000)
product <- data.frame(id=id,name=name,price=price)
product
product <-rbind(product,c("A001","Mouse",30000))
#중복된 행 탐지
duplicated(product) #output:FALSE FALSE FALSE  TRUE -> 마지막 행이 중복됨을 알 수 있다.
#중복되지 않은 행 출력
product[!duplicated(product),]
#output
    id     name price
1 A001    Mouse 30000
2 A002 Keyboard 90000
3 A006      USB 50000

#which 함수 사용, 중복된 행의 인덱스를 먼저 파악할 수 있다.  
which(duplicated(product)) #output:4 -> duplicated를 통해 나오는 논리값중 true에 해당하는 index를 출력한다.
index <- which(duplicated(product)) 
product[-index,] #음의 인덱스를 지정하면, 그 인덱스를 제외한 나머지 값들을 출력한다. 여기서는 음의 행을 제외한 나머지 행들을 출력한다.

#중복되는 행을 파악할 것까지 없고 그냥 중복되는 행만 제거한다면, unique()함수 사용
unique(product) #중복된 행이 제거된다.

#complete.cases 함수:중복된 행 뿐만 아니라 데이터 셋에 있는 결측값이 포함된 행을 제거하는 함수 
str(airquality) #airquality 데이터 셋에는 결측값이 많이 내포되어 있다. 
complete.cases(airquality) #결측값이 없으면 TRUE를 반환하고, 있으면 FALSE를 반환한다.
airquality.nona <- airquality[complete.cases(airquality),]
airquality.nona #결측값이 포함되어 있지 않은 온전한 행만을 가지고 있는 서브셋

#na.omit 함수 사용하면, na값이 제거된 서브셋을 구할 수 있다.
airquality.nona1 <- na.omit(airquality)

#데이터 값들을 일정 구간별로 몇 개의 그룹으로 범주화시켜야 할 때가 있다. 
#예를 들어 일정 구간 별로 관측값들의 빈도를 계산하고 싶을 때 구간 범주 생성
#cut 함수 사용 
cut(x=,breaks=) #x에는 구간별로 범주화하고 싶은 숫자 벡터, break에는 벡터나 정수로 구간을 지정한다.
cut(x=iris$Sepal.Width,breaks =c(0,1,2,3,4,5))
[1] (3,4] (2,3] (3,4] (3,4] (3,4] (3,4] (3,4] (3,4] (2,3]
[10] (3,4] (3,4] (3,4] (2,3] (2,3] (3,4] (4,5] (3,4] (3,4]
[19] (3,4] (3,4] (3,4] (3,4] (3,4] (3,4] (3,4] (2,3] (3,4]
[28] (3,4] (3,4] (3,4] (3,4] (3,4] (4,5] (4,5] (3,4] (3,4]
[37] (3,4] (3,4] (2,3] (3,4] (3,4] (2,3] (3,4] (3,4] (3,4]
[46] (2,3] (3,4] (3,4] (3,4] (3,4] (3,4] (3,4] (3,4] (2,3]
[55] (2,3] (2,3] (3,4] (2,3] (2,3] (2,3] (1,2] (2,3] (2,3]
[64] (2,3] (2,3] (3,4] (2,3] (2,3] (2,3] (2,3] (3,4] (2,3]
[73] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3]
[82] (2,3] (2,3] (2,3] (2,3] (3,4] (3,4] (2,3] (2,3] (2,3]
[91] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3]
[100] (2,3] (3,4] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3] (2,3]
[109] (2,3] (3,4] (3,4] (2,3] (2,3] (2,3] (2,3] (3,4] (2,3]
[118] (3,4] (2,3] (2,3] (3,4] (2,3] (2,3] (2,3] (3,4] (3,4]
[127] (2,3] (2,3] (2,3] (2,3] (2,3] (3,4] (2,3] (2,3] (2,3]
[136] (2,3] (3,4] (3,4] (2,3] (3,4] (3,4] (3,4] (2,3] (3,4]
[145] (3,4] (2,3] (2,3] (2,3] (3,4] (2,3]
Levels: (0,1] (1,2] (2,3] (3,4] (4,5]
#breaks에 구간을 0~1, 1~2, 2~3, 3~4, 4~5로 주었다.

cut(x=iris$Sepal.Width,breaks =5) #breaks에 정수를 넣으면 임의로 5개의 구간을 나눠서 관측값들을 구간별로 나눈다.
#output
[1] (3.44,3.92] (2.96,3.44] (2.96,3.44] (2.96,3.44]
[5] (3.44,3.92] (3.44,3.92] (2.96,3.44] (2.96,3.44]
[9] (2.48,2.96] (2.96,3.44] (3.44,3.92] (2.96,3.44]
[13] (2.96,3.44] (2.96,3.44] (3.92,4.4]  (3.92,4.4] 
[17] (3.44,3.92] (3.44,3.92] (3.44,3.92] (3.44,3.92]
[21] (2.96,3.44] (3.44,3.92] (3.44,3.92] (2.96,3.44]
[25] (2.96,3.44] (2.96,3.44] (2.96,3.44] (3.44,3.92]
[29] (2.96,3.44] (2.96,3.44] (2.96,3.44] (2.96,3.44]
[33] (3.92,4.4]  (3.92,4.4]  (2.96,3.44] (2.96,3.44]
[37] (3.44,3.92] (3.44,3.92] (2.96,3.44] (2.96,3.44]
[41] (3.44,3.92] (2,2.48]    (2.96,3.44] (3.44,3.92]
[45] (3.44,3.92] (2.96,3.44] (3.44,3.92] (2.96,3.44]
[49] (3.44,3.92] (2.96,3.44] (2.96,3.44] (2.96,3.44]
[53] (2.96,3.44] (2,2.48]    (2.48,2.96] (2.48,2.96]
[57] (2.96,3.44] (2,2.48]    (2.48,2.96] (2.48,2.96]
[61] (2,2.48]    (2.96,3.44] (2,2.48]    (2.48,2.96]
[65] (2.48,2.96] (2.96,3.44] (2.96,3.44] (2.48,2.96]
[69] (2,2.48]    (2.48,2.96] (2.96,3.44] (2.48,2.96]
[73] (2.48,2.96] (2.48,2.96] (2.48,2.96] (2.96,3.44]
[77] (2.48,2.96] (2.96,3.44] (2.48,2.96] (2.48,2.96]
[81] (2,2.48]    (2,2.48]    (2.48,2.96] (2.48,2.96]
[85] (2.96,3.44] (2.96,3.44] (2.96,3.44] (2,2.48]   
[89] (2.96,3.44] (2.48,2.96] (2.48,2.96] (2.96,3.44]
[93] (2.48,2.96] (2,2.48]    (2.48,2.96] (2.96,3.44]
[97] (2.48,2.96] (2.48,2.96] (2.48,2.96] (2.48,2.96]
[101] (2.96,3.44] (2.48,2.96] (2.96,3.44] (2.48,2.96]
[105] (2.96,3.44] (2.96,3.44] (2.48,2.96] (2.48,2.96]
[109] (2.48,2.96] (3.44,3.92] (2.96,3.44] (2.48,2.96]
[113] (2.96,3.44] (2.48,2.96] (2.48,2.96] (2.96,3.44]
[117] (2.96,3.44] (3.44,3.92] (2.48,2.96] (2,2.48]   
[121] (2.96,3.44] (2.48,2.96] (2.48,2.96] (2.48,2.96]
[125] (2.96,3.44] (2.96,3.44] (2.48,2.96] (2.96,3.44]
[129] (2.48,2.96] (2.96,3.44] (2.48,2.96] (3.44,3.92]
[133] (2.48,2.96] (2.48,2.96] (2.48,2.96] (2.96,3.44]
[137] (2.96,3.44] (2.96,3.44] (2.96,3.44] (2.96,3.44]
[141] (2.96,3.44] (2.96,3.44] (2.48,2.96] (2.96,3.44]
[145] (2.96,3.44] (2.96,3.44] (2.48,2.96] (2.96,3.44]
[149] (2.96,3.44] (2.96,3.44]
5 Levels: (2,2.48] (2.48,2.96] (2.96,3.44] ... (3.92,4.4]

#빈도를 계산하기 위해 table & summary 함수 사용
iris.cut <-cut(x=iris$Sepal.Width,breaks =c(0,1,2,3,4,5))
table(iris.cut)
#output
(0,1] (1,2] (2,3] (3,4] (4,5] 
   0     1    82    64     3

summary(iris.cut)
#output
(0,1] (1,2] (2,3] (3,4] (4,5] 
    0     1    82    64     3

#lable인수에 이름을 지정하면 좀 더 의미있는 구간 이름을 지정할 수 있다.
iris.cut <- cut(x=iris$Sepal.Width,
                breaks =c(0,1,2,3,4,5),
                labels=c("Smaller","Small","Medium","Big","Bigger"))
iris.cut #구간들이 구간별로 지정한 이름으로 지정되어 있는 것을 확인할 수 있다.
table(iris.cut)
#output
Smaller   Small  Medium     Big  Bigger 
      0       1      82      64       3 
    


