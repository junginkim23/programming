# -*- coding: utf-8 -*-
"""python_basic7

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GgNo2zrT4V6qDE9UEnJS3fyvKvTu12Wk
"""

## 스택 
stack = []  # 리스트를 스택으로 사용

# 삽입(push)연산 : append()
stack.append('a')
stack.append('b')
stack.append('c')

print(stack)
# 삭제(pop) 연산 : pop()
# pop() 연산은 삭제한 원소를 return 하며 해당 값은 스택에서 제거됨
# print(stack.pop())  # 'c'를 return & stack에서 'c' 삭제
# print(stack)
# print(stack.pop()) # 'b'를 return & stack에서 'b' 삭제
# print(stack)

# 현재 상태의 top 원소를 알기 위해서 [-1] 인덱싱을 이용
print(stack[-1])

## 스택 연습문제
## URL : https://www.acmicpc.net/problem/4949

line = input()  

stack = []

for c in line:
  if c == "(":
    stack.append('(')
  elif c == "[":
    stack.append('[')

  elif c == ')':
    if not stack:
      print('no')
      break
    elif stack[-1] != '(':
      print('no')
      break 
    stack.pop()
    
  elif c == ']':
    if not stack:
      print('no')
      break
    elif stack[-1] != '[':
      print('no')
      break 
    stack.pop()

else :
  if not stack:
    print('yes')
  else : 
    print('no')

stack = [ ]
sentence = input()


for c in sentence:
  if c == '(':
    stack.append(c)
  
  elif c == '[':
    stack.append(c)

  elif c == ')':
    if not stack:
      print('no')
      break
    elif stack[-1] != '(':
      print('no')
      break
    else :
      stack.pop()

  elif c == ']':
    if not stack: 
      print('no')
      break
    elif stack[-1] != '[':
      print('no')
      break
    else :
      stack.pop()

else :
  if not stack:
    print('yes')
  else:
    print('no')

import collections 

def solution(bridge_length, weight, truck_weights):
    answer = 0
    wait = collections.deque(truck_weights) 
    start = collections.deque()
    start.append(wait.popleft())
    
    
    while(True):
        if sum(start) > weight :
            answer += 1
            if bridge_length%answer==0:
                start.popleft()
                answer +=1
            print(start)
            assert()
        else :
            if not start:
                break
            answer += 1
            start.append(wait.popleft())
            print(start)       
            # assert()
    return answer

bridge_length=2
weight=10
truck_weights=[7,4,5,6]
solution(bridge_length,weight,truck_weights)

## 스택 문제 
'''
So when I die (the [first] I will see in (heaven) is a score list).
[ first in ] ( first out ).
Half Moon tonight (At least it is better than no Moon at all].
A rope may form )( a trail in a maze.
Help( I[m being held prisoner in a fortune cookie factory)].
([ (([( [ ] ) ( ) (( ))] )) ]).
 .
.
'''

## 큐 
# collections의 deque("덱")을 큐 자료 구조로 사용
# list는 Dequeue시 발생되는 원소들의 앞당김 비용이 너무 큼 
# deque : Double Ended Queue
# 양쪽에서 삽입(enqueue), 삭제(dequeue)가 가능 

import collections
queue = collections.deque()

# 오른쪽 enqueue 
queue.append('a')
queue.append('b')
queue.append('c')

print(queue)
# 왼쪽 dequeue
print(queue.popleft())

print(queue)
# front
print(queue[0])

queue = collections.deque()

# 왼쪽 enqueue 
queue.appendleft('a')
queue.appendleft('b')
queue.appendleft('c')

print(queue)
# 오른쪽 dequeue
print(queue.pop())

print(queue)
# Rear
print(queue[0])

list=[2,3,5,6,7,2]
test = collections.deque(list)
test
4%2

## 큐 연습문제
## URL : https://www.acmicpc.net/problem/2161  

import collections
queue = collections.deque()

N = int(input())

for a in range(7) :
  queue.append(a+1)

while True:
  print_left=queue.popleft()
  print(print_left,end=' ')
  if not queue:
    break
  go_back=queue.popleft()
  queue.append(go_back)

import collections
queue = collections.deque()
front,rear = -1,-1
N = int(input())

for a in range(1,N+1):
  queue.append(a)


while(True):
  left = queue.popleft()
  print(left,end=' ')
  if not queue:
    break
  right = queue.popleft()
  queue.append(right)

'''
7
1 3 5 7 4 2 6
'''

def solution(prices):
    answer = [0] * len(prices)
    for i in range(len(prices)):
        for j in range(i+1, len(prices)):
            if prices[i] <= prices[j]:
                answer[i] += 1
            else:
                answer[i] += 1
                break
    return answer

prices = [1,2,3,2,3]
print(solution(prices))

import math
process=[93,30,55]
a=[1,30,5]
list=[]
for i in range(len(process)):
  list.append((100-process[i])%a[i])
print(list)

import math 

def solution(progresses, speeds):
    answer = []
    days = []
    day = 1 
    for i in range(len(progresses)):
        days.append(int(math.ceil(100-progresses[i])/speeds[i]))
    max_day = days[0]
    for i in range(1,len(progresses)):
      if max_day < days[i]:
        answer.append(day)
        
        day = 1 
        max_day = days[i]
      
      else:
        day+=1
    answer.append(day)
     
    return answer

import time
s= time.time()
print(solution(process,a))
print(time.time()-s)



print(solution(process,a))